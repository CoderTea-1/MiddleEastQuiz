<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geography Master Quiz</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <style>
        body { margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; height: 100vh; background: #f4f4f4; }
        #header { background: #2c3e50; color: white; padding: 15px; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        #map { flex-grow: 1; cursor: crosshair; }
        #ui-overlay { position: absolute; top: 100px; left: 20px; z-index: 1000; width: 320px;
                      background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .success { color: #27ae60; font-weight: bold; }
        .error { color: #c0392b; font-weight: bold; }
        .info { font-size: 0.9em; color: #666; margin-top: 5px; }
        button { width: 100%; padding: 10px; margin-top: 10px; cursor: pointer; background: #3498db; color: white; border: none; border-radius: 6px; font-weight: bold; }
        button:hover { background: #2980b9; }
    </style>
</head>
<body>

<div id="header">
    <h1>Advanced Geography Quiz</h1>
</div>

<div id="ui-overlay">
    <h2 id="target-name">Loading...</h2>
    <p id="instruction"></p>
    <div id="feedback"></div>
    <button id="next-btn" style="display:none;" onclick="nextQuestion()">Next Question</button>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

<script>
    // --- UPDATED GEODATA WITH PATHS AND BOUNDS ---
    const quizData = [
        // RIVERS: Defined by Start (Source) and End (Mouth) + path logic
        {
            name: "Nile", type: "river", 
            path: [[15.5, 32.5], [24, 32.8], [31, 31]], // Approximated major bends
            countries: "Ethiopia, Sudan, Egypt",
            info: "Flows North from Lake Victoria/Blue Nile to the Mediterranean."
        },
        {
            name: "Indus", type: "river", 
            path: [[34, 78], [34, 73], [24, 67]], 
            countries: "China, India, Pakistan",
            info: "Flows from Himalayas to the Arabian Sea."
        },
        {
            name: "Tigris", type: "river", 
            path: [[38, 39], [36, 43], [31, 47]], 
            countries: "Turkey, Iraq",
            info: "The eastern member of the two great rivers of Mesopotamia."
        },
        // SEAS/OCEANS: Defined by Bounding Boxes [SouthLat, WestLon, NorthLat, EastLon]
        {
            name: "Red Sea", type: "sea", 
            bounds: [[12.5, 32.0], [29.8, 43.5]]
        },
        {
            name: "Caspian Sea", type: "sea", 
            bounds: [[36.5, 46.5], [47.2, 54.8]]
        },
        {
            name: "Mediterranean Sea", type: "sea", 
            bounds: [[30.0, -5.8], [45.8, 36.2]]
        },
        {
            name: "Indian Ocean", type: "sea", 
            bounds: [[-40.0, 30.0], [20.0, 110.0]]
        },
        // COUNTRIES
        { name: "Afghanistan", type: "country" },
        { name: "India", type: "country" },
        { name: "Egypt", type: "country" },
        // CITIES
        { name: "Istanbul", type: "city", lat: 41.0082, lon: 28.9784 }
    ];

    let currentIndex = 0;
    let map, drawControl, currentLayer;
    let score = 0;

    function initMap() {
        map = L.map('map').setView([25, 45], 3);
        
        // Using a clean, label-free map so users can't read the answers
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OpenStreetMap'
        }).addTo(map);

        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        drawControl = new L.Control.Draw({
            draw: { polygon: false, marker: false, circle: false, circlemarker: false, rectangle: false, 
                    polyline: { shapeOptions: { color: '#2980b9', weight: 4 } } }
        });

        map.on(L.Draw.Event.CREATED, (e) => {
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            validateRiver(e.layer);
        });

        map.on('click', onMapClick);
        loadQuestion();
    }

    function loadQuestion() {
        const q = quizData[currentIndex];
        document.getElementById('target-name').innerText = q.name;
        document.getElementById('feedback').innerText = "";
        document.getElementById('next-btn').style.display = "none";
        
        if(q.type === 'river') {
            document.getElementById('instruction').innerText = `Trace the path of the river through ${q.countries}. Use the line tool.`;
            map.addControl(drawControl);
        } else {
            document.getElementById('instruction').innerText = `Click on the ${q.type}.`;
            map.removeControl(drawControl);
        }
    }

    async function onMapClick(e) {
        const q = quizData[currentIndex];
        if (q.type === 'river' || document.getElementById('next-btn').style.display === "block") return;

        let isCorrect = false;

        if (q.type === 'sea') {
            const b = q.bounds;
            isCorrect = (e.latlng.lat >= b[0][0] && e.latlng.lat <= b[1][0] && 
                         e.latlng.lng >= b[0][1] && e.latlng.lng <= b[1][1]);
        } else if (q.type === 'country') {
            isCorrect = await checkOSM(e.latlng, q.name);
        } else if (q.type === 'city') {
            const dist = e.latlng.distanceTo(L.latLng(q.lat, q.lon));
            isCorrect = dist < 100000; // 100km
        }

        handleResult(isCorrect);
    }

    async function checkOSM(latlng, name) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&zoom=3`);
            const data = await response.json();
            return data.display_name && data.display_name.includes(name);
        } catch (e) { return false; }
    }

    function validateRiver(layer) {
        const q = quizData[currentIndex];
        const userPath = layer.getLatLngs();
        
        // Simple validation: check if user's start and end points are near our predefined path
        const startDist = userPath[0].distanceTo(L.latLng(q.path[0]));
        const endDist = userPath[userPath.length-1].distanceTo(L.latLng(q.path[q.path.length-1]));

        handleResult(startDist < 500000 && endDist < 500000);
    }

    function handleResult(correct) {
        const q = quizData[currentIndex];
        const feedback = document.getElementById('feedback');
        if (correct) {
            feedback.innerHTML = `<span class="success">Perfect!</span><br><small>${q.info || ""}</small>`;
            score++;
        } else {
            feedback.innerHTML = `<span class="error">Incorrect.</span>`;
            // Show the actual location for learning
            if(q.type === 'river') L.polyline(q.path, {color: 'green'}).addTo(map);
            if(q.lat) L.marker([q.lat, q.lon]).addTo(map);
        }
        document.getElementById('next-btn').style.display = "block";
    }

    function nextQuestion() {
        currentIndex++;
        if (currentIndex < quizData.length) {
            loadQuestion();
        } else {
            document.getElementById('ui-overlay').innerHTML = `<h2>Quiz Complete</h2><p>Your Final Score: ${score}/${quizData.length}</p>`;
        }
    }

    window.onload = initMap;
</script>
</body>
</html>